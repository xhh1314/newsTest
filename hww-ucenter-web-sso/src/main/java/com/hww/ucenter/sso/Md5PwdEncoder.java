package com.hww.ucenter.sso;

import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import org.apache.commons.codec.binary.Hex;
import org.springframework.security.crypto.password.PasswordEncoder;


public class Md5PwdEncoder  implements PasswordEncoder {

	public String encode(CharSequence password) {
		String p=password.toString();
		String res=encodePassword( p);
		return res;
	}

	
	public boolean matches(CharSequence rawPassword, String encodePassword) {
		// 判断密码是否存在
		if (rawPassword == null) {
			return false;
		}
		String p=rawPassword.toString();
		//通过md5加密后的密码
		String pass = this.encode(p);
		//比较密码是否相等的问题
		return pass.equals(encodePassword);
	}
   
	
    //TODO sault写死
    private   String defaultSalt = "HWWUCENTER";

    public String encodePassword(String rawPass) {
        return encodePassword(rawPass, defaultSalt);
    }

    public String encodePassword(String rawPass, String salt) {
        String saltedPass = mergePasswordAndSalt(rawPass, salt, false);
        MessageDigest messageDigest = getMessageDigest();
        byte[] digest;
        try {
            digest = messageDigest.digest(saltedPass.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("UTF-8 not supported!");
        }
        return new String(Hex.encodeHex(digest));
    }

    public boolean isPasswordValid(String encPass, String rawPass) {
        return isPasswordValid(encPass, rawPass, defaultSalt);
    }

    public boolean isPasswordValid(String encPass, String rawPass, String salt) {
        if (encPass == null) {
            return false;
        }
        String pass2 = encodePassword(rawPass, salt);
        return encPass.equals(pass2);
    }

    protected final MessageDigest getMessageDigest() {
        String algorithm = "MD5";
        try {
            return MessageDigest.getInstance(algorithm);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException("No such algorithm ["
                    + algorithm + "]");
        }
    }

    /**
     * Used by subclasses to extract the password and salt from a merged
     * <code>String</code> created using
     * {@link #mergePasswordAndSalt(String, Object, boolean)}.
     * <p>
     * The first element in the returned array is the password. The second
     * element is the salt. The salt array element will always be present, even
     * if no salt was found in the <code>mergedPasswordSalt</code> argument.
     * </p>
     *
     * @param mergedPasswordSalt as generated by <code>mergePasswordAndSalt</code>
     * @return an array, in which the first element is the password and the
     * second the salt
     * @throws IllegalArgumentException if mergedPasswordSalt is null or empty.
     */
    protected String mergePasswordAndSalt(String password, Object salt,
                                          boolean strict) {
        if (password == null) {
            password = "";
        }
        if (strict && (salt != null)) {
            if ((salt.toString().lastIndexOf("{") != -1)
                    || (salt.toString().lastIndexOf("}") != -1)) {
                throw new IllegalArgumentException(
                        "Cannot use { or } in salt.toString()");
            }
        }
        if ((salt == null) || "".equals(salt)) {
            return password;
        } else {
            return password + "{" + salt.toString() + "}";
        }
    }

    /**
     * 获得混淆码
     *
     * @return
     */
    public String getDefaultSalt() {
        return defaultSalt;
    }

    /**
     * 设置混淆码
     *
     * @param defaultSalt
     */
    public void setDefaultSalt(String defaultSalt) {
        this.defaultSalt = defaultSalt;
    }


    public static void main(String[] args) {
        Md5PwdEncoder d = new Md5PwdEncoder();
        System.out.println(d.encodePassword("12345678@"));//7b695d3442deeb402d93cb689c06d1f9
    }
}
